# UART
Implementation of UART using Verilog HDL .
## Specifications
Data packets are 8 bits long , no parity bit included , 1 start bit , 1 or 2 stop bits deteremined by the parameter "SBIT" , able to operate on 4 baudrates (4800,9600,19200,38400) determined using the "B_rate" signal.
## Construction
The top level is shown in the figure below , it consist of 5 modules , UART_TX , UART_RX , FIFO_RX , FIFO_TX , BAUD_GEN 
![Presentation1](https://github.com/mahmoudyousry32/UART/assets/123260720/6bd5e53a-b464-451a-880f-6d7bda836d1e) 
### Baud_gen 
this is the baud generator it generates the sampling signal whose frequency is 16 time the UART's designated baud rate for the recieving module UART_RX , The sampling tick is also used to drive the transmitter module where a bit is shifted out every 16 ticks (the sampling signal acts as an enable signal rather than a clock signal that is to avoid creating multiple clock domains and violating synchronous design ).

the sampling tick is generated every $M = {f\over 16*b}$ where f is the systems's clock frequency and b is the designated baudrate 
so for a system clock of 100Mhz and for baudrates (4800,9600,19200,38400) we would have M equals to (1302,651,325,162) clock cycles
all of M's values are rounded off to the nearest integer which would introduce some error or a discrepency between the desired baudrate and the acutal generated baudrate.

### UART_TX
This is the transmitter module. It basically performs a parallel to serial conversion where the parallel data is loaded into the fifo register. The tx module begins transmission as soon as data is loaded into the fifo register.
We observe that the empty signal is connected through an inverter to the tx_start port in the UART_TX module, so as soon as a byte of data is loaded into the fifo register, the UART begins transmission, and the tx_done signal is used to 
tell the fifo register to load the next byte to be transmitted, the UART_TX module keeps transmitting until the tx fifo is empty and the empty signal is asserted.
the UART_TX consists of mainly of five register, two register the tx_idle and the tx_done registers are flag registers to indicate whether the transmitter is done transmitting and whether its busy or not, the third register s_tick_count and keeps track of the number of sampling ticks generated by the the baud_generator module, the fourth register dbits_count keeps track of the number of data bits transmitted and finally the fifth register is a parallel in serial out shift register which shifts out the data bits every 16 sampling ticks , these five registers are considered to be the datapath of the transmitter, the registers are controlled by a simple FSM which generates the necessary control signals for loading and resetting the registers of the datapath .
### UART_RX
Similar to the transmitter module the receiver module consists mainly of a FSM machine which controls the datapath registers , the datapath registers are similar to those in the transmitter module we have the s_tick_count which keeps track of the number of sampling ticks while the dbits_count register keeps track of the number of data bits sampled the rx_done register is just a flag register which is connected to the wr pin of the rx fifo register its used to tell the rx fifo register that a byte has been successfully received and that its ready to be loaded in the FIFO.
### RX and TX FIFO registers
FIFO registers are placed to act as cushions between the UART and a processor subsystem as i am planning to use this UART as an I/O core with a softcore processor (Microblaze MCS) the FIFOs are needed because the data processing rate of a UART is much slower than the rate of the FPGA's softcore processor so for example instead of waiting for the UART to complete transmission the processor can just write several bytes to the transmitter's FIFO buffer and then continue doing other tasks . 
## Transmission example
Here is an example for transmitting a byte at 38400 baudrate , the "rx_reg" is the register responsible for sampling data at the recieiving end 
![image](https://github.com/mahmoudyousry32/UART/assets/123260720/b7024aa1-a085-4660-883b-7357be03033e)
oversampling is used the sampling rate is 16 times the baud rate, which means that
each serial bit is sampled 16 times. Assume that the communication uses N data bits
and M stop bits. The oversampling scheme works as follows:
1) Wait until the incoming signal becomes 0, the beginning of the start bit, and
then start the sampling tick counter.
2) When the counter reaches 7, the incoming signal reaches the middle point of the
start bit. Clear the counter to 0 and restart.
3) When the counter reaches 15, the incoming signal progresses for one bit and
reaches the middle of the first data bit. Retrieve its value, shift it into a register,
and restart the counter.
4) Repeat step 3 n-1 more times to retrieve the remaining data bits.
5) If the optional parity bit is used, repeat step 3 one time to obtain the parity bit.
6) Repeat step 3 n more times to obtain the stop bits.
